# 第7周学习笔记 #

## 字典树 ##

又称Trie树，单词查找树或键树，一种树形数据结构。

典型应用：统计和排序大量的字符串（不仅限于字符串），常被搜索引擎用于文本词频统计。

优点：最大限度的减少无谓的字符串比较，查询效率比哈希表高。

数据结构：至少是26叉树；每个节点存储分叉信息，以及额外信息(单词频次)。

核心思想：
空间换时间（结构复杂，最大查询次数为查询单词的字符长度）；
利用字符串公共前缀来降低查询时间的开销，以达到提高效率的目的。

基本性质：
节点不存储完整单词；每个分叉代表一个字母；
从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；
每个节点的所有子节点路径表示的字符都不同；

## 并查集 DisjoinSet ##

适用场景
组团、配对问题（组团是否相同组团，组团合并；判断两个人是否朋友）

基本操作

makeSet(s): 建立一个新的并查集，其中包含s个单元素集合；

unionSet(x,y): 把元素x和元素y所在的集合合并，要求x和y所在集合不想交，如果相交则不合并；

find(x): 找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。

初始化：每个元素有个parent指向自己
查询、合并：集合代表元素(parent指向自己的元素);
路径压缩 利用find进行

## 高级搜索 ##

剪枝、双向BFS、启发式搜索(A*)

优化方式：不重复、剪枝

搜索方向：DFS(栈)、BFS(队列)

双向搜索：两端同时开始BFS

启发式搜索：采用优先队列

剪枝：无效分支、差分支、次优分支

双向BFS代码模版

bool BidirectionBFS(graph, start, end)
{

    queueS.push(start);
    queueE.push(end);
    while (!queueS.empty() && !queueE.empty())
     {
          node = queueS.front();
          queueS.pop();
          visited.add(node);
          process(node);
          queueE.contain(node) return true;
          nodes = node.children();
          unvisited = getUnvisited(nodes, visited);
          queueS.push(unvisited);
          if (queueS.size() > queueE.size())
              swap(queueS, queueE);
     }

}

## 回溯法 ##

采用试错思想，尝试分步解决问题。过程中，当通过尝试发现当前分步的答案不能得到有效的正确解时，将取消上一步甚至几步的计算，再通过其他的可能的分布解答在此尝试寻找问题的答案。

通常用最简单的递归方法实现，在反复试错后可能会出现两种情况：找到一个可能存在的正确答案；在尝试了所有可能的分步方法后确定无解。

最坏情况下，回溯会导致一次复杂度为指数时间的计算。

## A*搜索 ##

采用优先队列实现

估价函数(启发式函数)：h(n)，用于评估哪些节点是最可能节点，函数返回一个非负实数，可以认为是从节点n到目标节点的路径的估计成本。

启发式函数是一种告知搜索方向的方法，提供了一种智能的方法猜测哪个节点会指向目标。











